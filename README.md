# MyDocker： 一个用 C++ 实现的极简容器引擎
欢迎来到 **MyDocker**，这是一个使用 C++ 从零开始构建一个简单而功能齐全的容器运行时的实践项目。本项目旨在通过寓教于乐的方式，揭开当您输入 `docker run` 时底层发生的一切的神秘面纱。

## 🌟 模拟实现的核心 Docker 功能
本项目并非要取代 Docker，而是专注于模拟实现容器化技术的核心机制。我们已经成功实现了以下功能：

1.  **命名空间 (Namespaces) - 实现隔离**
    *   **PID 命名空间 (`CLONE_NEWPID`):** 容器拥有自己独立的进程树，起始进程的 PID 为 1。在容器内部，您只能看到属于它自己的进程。
    *   **挂载命名空间 (`CLONE_NEWNS`):** 每个容器都获得一个隔离的文件系统视图。我们通过 `chroot` 系统调用和挂载一个专用的 `/proc` 文件系统来实现这一点。
    *   **UTS 命名空间 (`CLONE_NEWUTS`):** 允许每个容器拥有自己独立的主机名。
    *   **网络命名空间 (`CLONE_NEWNET`):** 提供网络隔离。我们使用 **`slirp4netns`** 来模拟无根模式（rootless）的网络，使容器能够访问互联网，而无需 root 权限来配置网络。
    *   **用户命名空间 (`CLONE_NEWUSER`):** 将容器内的 root 用户 (UID 0) 映射到宿主机上的一个非特权用户，从而显著增强安全性。这是“无根容器”技术的基础。

2.  **控制组 (Cgroups) - 实现资源限制**
    *   我们利用 **控制组 (v2)** 来对容器实施资源约束。
    *   **内存限制:** 限制容器只能使用特定数量的内存（例如 100MB）。
    *   **CPU 限制:** 将容器的 CPU 使用率限制在一个预定义的配额内（例如一个 CPU 核心的 50%）。

3.  **客户端-服务器架构**
    *   本项目模仿了 Docker 的 `dockerd` (守护进程) 和 `docker` (客户端) 模型。
    *   **守护进程 (`sudo ./my-docker`):** 一个以 root 权限运行的后台进程，负责管理容器的整个生命周期。它通过一个 Unix 域套接字 (`/var/run/my-docker.sock`) 监听命令。
    *   **客户端 (`./my-docker run ...`):** 一个非特权的命令行工具，它与守护进程通信，以创建容器并与之交互。

4.  **交互式 TTY (伪终端)**
    *   我们为容器实现了一个功能完备的交互式伪终端 (PTY)。
    *   这提供了真实的交互式 Shell 体验，支持命令历史、行编辑，并能运行如 `vim` 和 `top` 这样的全屏应用程序。
    *   我们使用 `poll()` 在客户端的终端和容器的 PTY 之间进行双向的 I/O 转发。

5.  **文件系统分层 (概念性实现)**
    *   虽然没有完整实现像 OverlayFS 这样的联合文件系统，但本项目使用了一个预先准备好的根文件系统 (`rootfs`) 目录。这模拟了容器镜像文件系统层的概念，为容器提供了自己隔离的根目录。

## 🎓 教育价值
MyDocker 的主要目标是学习。通过构建这个项目，您将对以下内容获得深刻且实践性的理解：

*   **Linux 系统调用:** 直接使用 `clone()`, `chroot()`, `mount()`, `sethostname()` 等。
*   **进程管理:** 熟练运用 `fork()`, `execvp()`, `waitpid()` 和信号处理。
*   **进程间通信 (IPC):** 使用 Unix 域套接字进行 C/S 通信，以及使用管道进行父子进程间的同步。
*   **容器技术基石:** 理解命名空间和控制组是如何成为所有容器技术的根本构建块。
*   **高级 I/O:** 实现基于 `poll()` 的非阻塞双向 I/O 转发和管理伪终端 (`pty`)。
*   **安全概念:** 理解有根容器和无根容器之间的关键区别，以及用户命名空间在降低安全风险中的作用。

## ⚠️ 功能限制
这是一个教育性项目，缺少许多生产级容器引擎所具备的功能：

*   **无镜像管理:** 没有容器镜像、分层或镜像仓库的概念。`rootfs` 必须在宿主机上手动准备。
*   **无联合文件系统:** 没有使用 OverlayFS 或类似技术。容器内的更改会直接写入 `rootfs` 目录。
*   **简化的网络:** 虽然 `slirp4netns` 提供了互联网访问，但不支持创建复杂的容器网络、端口映射或 DNS 服务。
*   **无持久化存储:** 没有卷管理功能，所有数据都是临时的。
*   **简化的命令行:** 命令行接口（CLI）非常基础。
*   **健壮性与错误处理:** 错误处理比较基础，未达到生产环境要求的健壮性。

## 🚀 如何使用

### 环境准备
*   一个 Linux 环境。
*   C++ 编译器 (`g++`), `make`。
*   必要的工具: `slirp4netns`。

### 1. 安装依赖
首先，安装必要的依赖项。
```bash
sudo apt-get update
sudo apt-get install slirp4netns
```

### 2. 准备根文件系统 (`rootfs`)
此步骤将创建一个我们的容器将用作其根目录的最小化根文件系统。
```bash
make build
```

### 3. 设置权限 (等同于 Docker 用户组)
我们的守护进程需要一个专门的用户组，以授权非 root 用户访问其套接字。
```bash
# 创建一个名为 'mydocker' 的用户组
sudo groupadd mydocker
# 将您当前的用户添加到这个组
sudo usermod -aG mydocker $USER
# 重要提示: 为了让用户组的更改生效，您必须
# 完全退出当前会话并重新登录，或者在终端中运行 'newgrp mydocker'。
```

### 4. 运行 MyDocker!
您需要**两个终端窗口**。

**在终端 1 (启动守护进程):**
使用 `sudo` 运行守护进程。它将开始监听客户端连接。
```sh
# sudo ./build/my-docker
make rund``````sh
# 预期输出:
[Daemon] Starting...
[Daemon] Listening on /var/run/my-docker.sock
```

**在终端 2 (运行一个容器):**
以**普通用户**身份运行客户端。它将连接到守护进程，并在一个新容器中启动一个交互式 Shell。
```bash
# ./my-docker run /bin/sh
make run
``````sh
# 现在您应该已经进入了容器的 Shell！
root@my-container:/# 
```

**在容器内部，您可以验证隔离性：**
```bash
# 检查 PID (应该是 1)
root@my-container:/# echo $$
# 查看进程 (应该只能看到容器自己的进程)
root@my-container:/# ps aux
# 查看主机名
root@my-container:/# hostname
# 退出容器
root@my-container:/# exit
```

要停止守护进程，请回到**终端 1** 并按下 `Ctrl+C`。